#include <SFML/Graphics.hpp>
#include <SFML/Audio.hpp>
#include <deque>
#include <cstdlib>
#include <ctime>
#include <iostream>

const int WIDTH = 800;
const int HEIGHT = 600;
const int BLOCK_SIZE = 20;
const int ROWS = HEIGHT / BLOCK_SIZE;
const int COLS = WIDTH / BLOCK_SIZE;

enum Direction { UP, DOWN, LEFT, RIGHT };

struct SnakeGame {
    sf::RenderWindow window;
    std::deque<sf::Vector2i> snake;
    sf::Vector2i food;
    Direction dir = RIGHT;
    sf::Clock clock;
    float speed = 0.15f;
    bool isGameOver = false;

    sf::SoundBuffer eatBuffer, gameOverBuffer;
    sf::Sound eatSound, gameOverSound;

    SnakeGame() : window(sf::VideoMode(WIDTH, HEIGHT), "Snake Game") {
        window.setFramerateLimit(60);
        srand(static_cast<unsigned>(time(nullptr)));

        snake.push_back({COLS / 2, ROWS / 2});
        spawnFood();

        eatBuffer.loadFromFile("assets/eat.wav");
        gameOverBuffer.loadFromFile("assets/game_over.wav");
        eatSound.setBuffer(eatBuffer);
        gameOverSound.setBuffer(gameOverBuffer);
    }

    void spawnFood() {
        while (true) {
            int x = rand() % COLS;
            int y = rand() % ROWS;
            food = {x, y};
            if (std::find(snake.begin(), snake.end(), food) == snake.end())
                break;
        }
    }

    void processInput() {
        sf::Event event;
        while (window.pollEvent(event)) {
            if (event.type == sf::Event::Closed)
                window.close();

            if (event.type == sf::Event::KeyPressed) {
                if (event.key.code == sf::Keyboard::Up && dir != DOWN) dir = UP;
                if (event.key.code == sf::Keyboard::Down && dir != UP) dir = DOWN;
                if (event.key.code == sf::Keyboard::Left && dir != RIGHT) dir = LEFT;
                if (event.key.code == sf::Keyboard::Right && dir != LEFT) dir = RIGHT;
            }
        }
    }

    void update() {
        if (clock.getElapsedTime().asSeconds() < speed) return;
        clock.restart();

        sf::Vector2i head = snake.front();
        switch (dir) {
            case UP: head.y -= 1; break;
            case DOWN: head.y += 1; break;
            case LEFT: head.x -= 1; break;
            case RIGHT: head.x += 1; break;
        }

        // Check wall or self collision
        if (head.x < 0 || head.x >= COLS || head.y < 0 || head.y >= ROWS ||
            std::find(snake.begin(), snake.end(), head) != snake.end()) {
            isGameOver = true;
            gameOverSound.play();
            return;
        }

        snake.push_front(head);

        if (head == food) {
            eatSound.play();
            spawnFood();
            if (speed > 0.05f) speed -= 0.005f;  // Increase difficulty
        } else {
            snake.pop_back();
        }
    }

    void render() {
        window.clear(sf::Color::Black);

        sf::RectangleShape block(sf::Vector2f(BLOCK_SIZE - 1, BLOCK_SIZE - 1));

        // Draw snake
        block.setFillColor(sf::Color::Green);
        for (auto& part : snake) {
            block.setPosition(part.x * BLOCK_SIZE, part.y * BLOCK_SIZE);
            window.draw(block);
        }

        // Draw food
        block.setFillColor(sf::Color::Red);
        block.setPosition(food.x * BLOCK_SIZE, food.y * BLOCK_SIZE);
        window.draw(block);

        if (isGameOver) {
            sf::Font font;
            font.loadFromFile("/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf");

            sf::Text gameOverText("Game Over!", font, 50);
            gameOverText.setFillColor(sf::Color::White);
            gameOverText.setPosition(WIDTH / 2 - 150, HEIGHT / 2 - 25);
            window.draw(gameOverText);
        }

        window.display();
    }

    void run() {
        while (window.isOpen()) {
            processInput();
            if (!isGameOver)
                update();
            render();
        }
    }
};

int main() {
    SnakeGame game;
    game.run();
    return 0;
}
